[General]
network = VehicleSync
#abstract-config = true (requires omnet 6)

sim-time-limit = 10s

# Ethernet links between switches are 1Gbps
*.frontSwitch.eth[0..4].bitrate = 1Gbps
*.frontLeftSwitch.eth[0..1].bitrate = 1Gbps
*.frontRightSwitch.eth[0..1].bitrate = 1Gbps
*.rearSwitch.eth[0..4].bitrate = 1Gbps
*.rearLeftSwitch.eth[0..1].bitrate = 1Gbps
*.rearRightSwitch.eth[0..1].bitrate = 1Gbps

# other Ethernet links are 100Mbps
*.*.eth[*].bitrate = 100Mbps

# wheel applications (source)
*.*Wheel.numApps = 1
*.*Wheel.app[0].typename = "UdpSourceApp"
*.*Wheel.app[0].source.packetNameFormat = "%M->engineActuator:CDT-%c"
*.*Wheel.app[0].source.packetLength = 175B
*.*Wheel.app[0].source.productionInterval = 500us # ~2.8Mbps
*.*Wheel.app[0].io.destAddress = "engineActuator"
*.frontLeftWheel.app[0].io.destPort = 1001
*.frontRightWheel.app[0].io.destPort = 1002
*.rearLeftWheel.app[0].io.destPort = 1003
*.rearRightWheel.app[0].io.destPort = 1004

# engine actuator applications (sink)
*.engineActuator.numApps = 5
*.engineActuator.app[*].typename = "UdpSinkApp"
*.engineActuator.app[0].display-name = "steering"
*.engineActuator.app[1].display-name = "front left wheel"
*.engineActuator.app[2].display-name = "front right wheel"
*.engineActuator.app[3].display-name = "rear left wheel"
*.engineActuator.app[4].display-name = "rear right wheel"
*.engineActuator.app[0].io.localPort = 1000
*.engineActuator.app[1].io.localPort = 1001
*.engineActuator.app[2].io.localPort = 1002
*.engineActuator.app[3].io.localPort = 1003
*.engineActuator.app[4].io.localPort = 1004

# TSN switches have time-aware shapers with two traffic classes
*.*Switch*.hasEgressTrafficShaping = true
*.*Switch*.eth[*].macLayer.queue.numTrafficClasses = 2
*.*Switch*.eth[*].macLayer.queue.classifier.typename = "ContentBasedClassifier"
*.*Switch*.eth[*].macLayer.queue.queue[*].typename = "DropTailQueue"
*.tsnSwitch*.eth[*].macLayer.queue.transmissionGate[0].clockModule = "^.^.^.^.clock"
*.*Switch*.eth[*].macLayer.queue.classifier.packetFilters = ["app*", "Gptp*"]
*.*Switch*.eth[*].macLayer.queue.transmissionGate[0].durations = [100us, 900us]
*.*Switch*.eth[*].macLayer.queue.transmissionGate[1].initiallyOpen = true
*.*Switch*.eth[*].macLayer.queue.transmissionGate[1].durations = []		# gate always open
*.tsnSwitch*.eth[*].macLayer.queue.transmissionGate[1].clockModule = "^.^.^.^.clock"

# enable time synchronization in all network nodes
*.*.hasTimeSynchronization = true

# all oscillators have a random constant drift
**.oscillator.typename = "ConstantDriftOscillator"
**.oscillator.driftRate = uniform(-150ppm, 150ppm)

# application traffic sources use the local clock of the network node
*.*.app[*].source.clockModule = "^.^.clock"

# periodic gates in all traffic shapers use the local clock of the network node
*.*.eth[*].macLayer.queue.transmissionGate[*].clockModule = "^.^.^.^.clock"

# TSN clock2 has multiple clocks
*.masterClock2.clock.typename = "MultiClock"
*.masterClock2.clock.numClocks = 2

# TSN clocks have multiple gPTP time synchronization domains
*.masterClock*.gptp.typename = "MultiDomainGptp"
*.masterClock.gptp.numDomains = 2
*.masterClock.gptp.domain[0..1].clockModule = "masterClock.clock"
*.masterClock.gptp.domain[0].masterPorts = ["eth0"]
*.masterClock.gptp.domain[1].masterPorts = ["eth0"]
*.masterClock2.gptp.numDomains = 4
*.masterClock2.gptp.domain[2..3].clockModule = "masterClock2.clock"
*.masterClock2.gptp.domain[0].gptpNodeType = "SLAVE_NODE"
*.masterClock2.gptp.domain[0].slavePort = "eth0"
*.masterClock2.gptp.domain[1].gptpNodeType = "SLAVE_NODE"
*.masterClock2.gptp.domain[1].slavePort = "eth0"
*.masterClock2.gptp.domain[2].gptpNodeType = "MASTER_NODE"
*.masterClock2.gptp.domain[2].masterPorts = ["eth0"]
*.masterClock2.gptp.domain[3].gptpNodeType = "MASTER_NODE"
*.masterClock2.gptp.domain[3].masterPorts = ["eth0"]

# switches have multiple clocks
*.*Switch.clock.typename = "MultiClock"
*.*Switch.clock.numClocks = 4

# switches have multiple gPTP time synchronization domains
*.*Switch.gptp.typename = "MultiDomainGptp"
*.*Switch.gptp.numDomains = 4

# frontSwitch
*.frontSwitch.gptp.domain[0].masterPorts = ["eth1"]
*.frontSwitch.gptp.domain[0].slavePort = "eth0"
*.frontSwitch.gptp.domain[1].masterPorts = ["eth2"]
*.frontSwitch.gptp.domain[1].slavePort = "eth0"
*.frontSwitch.gptp.domain[2].masterPorts = ["eth1"]
*.frontSwitch.gptp.domain[2].slavePort = "eth2"
*.frontSwitch.gptp.domain[3].masterPorts = ["eth2"]
*.frontSwitch.gptp.domain[3].slavePort = "eth1"

# frontLeftSwitch
*.frontLeftSwitch.gptp.domain[0].masterPorts = ["eth1", "eth2"]
*.frontLeftSwitch.gptp.domain[0].slavePort = "eth0"
*.frontLeftSwitch.gptp.domain[1].masterPorts = ["eth2"]
*.frontLeftSwitch.gptp.domain[1].slavePort = "eth1"
*.frontLeftSwitch.gptp.domain[2].masterPorts = ["eth1", "eth2"]
*.frontLeftSwitch.gptp.domain[2].slavePort = "eth0"
*.frontLeftSwitch.gptp.domain[3].masterPorts = ["eth0", "eth2"]
*.frontLeftSwitch.gptp.domain[3].slavePort = "eth1"

# rearLeftSwitch
*.rearLeftSwitch.gptp.domain[0].masterPorts = ["eth1", "eth2"]
*.rearLeftSwitch.gptp.domain[0].slavePort = "eth0"
*.rearLeftSwitch.gptp.domain[1].masterPorts = ["eth0", "eth2"]
*.rearLeftSwitch.gptp.domain[1].slavePort = "eth1"
*.rearLeftSwitch.gptp.domain[2].masterPorts = ["eth2"]
*.rearLeftSwitch.gptp.domain[2].slavePort = "eth0"
*.rearLeftSwitch.gptp.domain[3].masterPorts = ["eth0", "eth2"]
*.rearLeftSwitch.gptp.domain[3].slavePort = "eth1"

# rearSwitch
*.rearSwitch.gptp.domain[0].masterPorts = ["eth0", "eth2"]
*.rearSwitch.gptp.domain[0].slavePort = "eth1"
*.rearSwitch.gptp.domain[1].masterPorts = ["eth0", "eth1"]
*.rearSwitch.gptp.domain[1].slavePort = "eth2"
*.rearSwitch.gptp.domain[2].masterPorts = ["eth2"]
*.rearSwitch.gptp.domain[2].slavePort = "eth0"
*.rearSwitch.gptp.domain[3].masterPorts = ["eth1"]
*.rearSwitch.gptp.domain[3].slavePort = "eth0"

# rearRightSwitch
*.rearRightSwitch.gptp.domain[0].masterPorts = ["eth1", "eth2"]
*.rearRightSwitch.gptp.domain[0].slavePort = "eth0"
*.rearRightSwitch.gptp.domain[1].masterPorts = ["eth0", "eth2"]
*.rearRightSwitch.gptp.domain[1].slavePort = "eth1"
*.rearRightSwitch.gptp.domain[2].masterPorts = ["eth1", "eth2"]
*.rearRightSwitch.gptp.domain[2].slavePort = "eth0"
*.rearRightSwitch.gptp.domain[3].masterPorts = ["eth2"]
*.rearRightSwitch.gptp.domain[3].slavePort = "eth1"

# frontRightSwitch
*.frontRightSwitch.gptp.domain[0].masterPorts = ["eth2"]
*.frontRightSwitch.gptp.domain[0].slavePort = "eth0"
*.frontRightSwitch.gptp.domain[1].masterPorts = ["eth0", "eth2"]
*.frontRightSwitch.gptp.domain[1].slavePort = "eth1"
*.frontRightSwitch.gptp.domain[2].masterPorts = ["eth1", "eth2"]
*.frontRightSwitch.gptp.domain[2].slavePort = "eth0"
*.frontRightSwitch.gptp.domain[3].masterPorts = ["eth0", "eth2"]
*.frontRightSwitch.gptp.domain[3].slavePort = "eth1"


# TSN devices have multiple clocks
*.*Wheel.clock.typename = "MultiClock"
*.*Wheel.clock.numClocks = 4

# TSN devices have multiple gPTP time synchronization domains
*.*Wheel.gptp.typename = "MultiDomainGptp"
*.*Wheel.gptp.numDomains = 4
*.frontLeftWheel.gptp.clockModule = "frontLeftWheel.clock"
*.rearLeftWheel.gptp.clockModule = "rearLeftWheel.clock"
*.rearRightWheel.gptp.clockModule = "rearRightWheel.clock"
*.frontRightWheel.gptp.clockModule = "frontRightWheel.clock"
*.*Wheel.gptp.domain[*].slavePort = "eth0"

# different initial gPTP pdelay measurement and time synchronization offsets
**.pdelayInitialOffset = 100us
*.*.gptp.domain[0].syncInitialOffset = syncInterval * 1 / 4
*.*.gptp.domain[1].syncInitialOffset = syncInterval * 2 / 4
*.*.gptp.domain[2].syncInitialOffset = syncInterval * 3 / 4
*.*.gptp.domain[3].syncInitialOffset = syncInterval * 4 / 4

# multiple data link visualizers display different gPTP time synchronization domain packets
*.visualizer.typename = "IntegratedMultiCanvasVisualizer"
*.visualizer.numDataLinkVisualizers = 4
*.visualizer.dataLinkVisualizer[*].displayLinks = true
*.visualizer.dataLinkVisualizer[*].activityLevel = "protocol"
*.visualizer.dataLinkVisualizer[0].packetFilter = expr(has(GptpSync) && GptpSync.domainNumber == 0)
*.visualizer.dataLinkVisualizer[1].packetFilter = expr(has(GptpSync) && GptpSync.domainNumber == 1)
*.visualizer.dataLinkVisualizer[2].packetFilter = expr(has(GptpSync) && GptpSync.domainNumber == 2)
*.visualizer.dataLinkVisualizer[3].packetFilter = expr(has(GptpSync) && GptpSync.domainNumber == 3)
*.visualizer.dataLinkVisualizer[0].tags = "primary GM domain0"
*.visualizer.dataLinkVisualizer[1].tags = "primary GM domain1"
*.visualizer.dataLinkVisualizer[2].tags = "hot-standby GM domain0"
*.visualizer.dataLinkVisualizer[3].tags = "hot-standby GM domain1"
*.visualizer.dataLinkVisualizer[0].lineColor = "blue4"
*.visualizer.dataLinkVisualizer[1].lineColor = "blue1"
*.visualizer.dataLinkVisualizer[2].lineColor = "red4"
*.visualizer.dataLinkVisualizer[3].lineColor = "red1"

[Config BaseOperation]
description = "Normal operation of time-aware shaping with time synchronization"

# change drift rate to make failover effect more visible
*.masterClock2.clock.clock[*].oscillator.driftRate = -30ppm

## source applications
#*.frontLeftWheel.numApps = 1
#*.frontLeftWheel.app[0].typename = "UdpSourceApp"
#*.frontLeftWheel.app[0].source.packetLength = 10B
#*.frontLeftWheel.app[0].source.productionInterval = 1ms
#*.frontLeftWheel.app[0].io.destAddress = "frontRightWheel"
#*.frontLeftWheel.app[0].io.destPort = 1000
#*.frontLeftWheel.app[0].source.clockModule = "^.^.clock"
#
## sink applications
#*.frontRightWheel.numApps = 1
#*.frontRightWheel.app[0].typename = "UdpSinkApp"
#*.frontRightWheel.app[0].io.localPort = 1000

# additional data link visualizers display application packets
*.visualizer.numDataLinkVisualizers = 5
*.visualizer.dataLinkVisualizer[0..3].fadeOutMode = "simulationTime"
*.visualizer.dataLinkVisualizer[0..3].fadeOutTime = 125ms
*.visualizer.dataLinkVisualizer[4].packetFilter = "source*"
*.visualizer.dataLinkVisualizer[4].tags = "application"
*.visualizer.dataLinkVisualizer[4].lineColor = "black"
*.visualizer.packetDropVisualizer[0].displayPacketDrops = true

[Config ClockFailure]
description = "Master clock link failure effects on time-aware shaping"
extends = BaseOperation

# Masterclock disconnects from the network at 5 seconds
*.scenarioManager.script = xml("<scenario> \
                                  <at t='5'> \
                                    <disconnect src-module='masterClock' src-gate='ethg[0]'/> \
                                  </at> \
                                </scenario>")

[Config Takeover]
description = "Hot-standby master clock takes over time synchronization"
extends = ClockFailure

# Masterclock disconnects from the network at 5 seconds
# all multi clocks switch to the 2nd clock submodule
*.scenarioManager.script = xml("<scenario> \
                                  <at t='5'> \
                                    <disconnect src-module='masterClock' src-gate='ethg[0]'/> \
                                  </at> \
                                  <at t='5'> \
                                    <set-param module='frontSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='frontLeftSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='rearLeftSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='rearSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='rearRightSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='frontRightSwitch.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='frontLeftWheel.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='rearLeftWheel.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='rearRightWheel.clock' par='activeClockIndex' value='2'/> \
                                    <set-param module='frontRightWheel.clock' par='activeClockIndex' value='2'/> \
                                  </at> \
                                </scenario>")
